import org.apache.thrift.TException;
import org.apache.thrift.transport.TTransportFactory;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSSLTransportFactory.TSSLTransportParameters;
import org.apache.thrift.protocol.TBinaryProtocol;
import java.util.*;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public class SNodeServiceHandler implements SNodeService.Iface
{
	private List<NodeInfo> allNodes = new ArrayList<NodeInfo>();
	private int nodeMax = 0;
	private boolean joinLock = false;
	private Set<Integer> checkKey = new HashSet<Integer>();
	private String curIp = "";
	private String curPort = "";

	// input is the string that you want to hash
	// the key generated by this function will be the MD5 code of the input
	// mod by range

	public SNodeServiceHandler(int n){
		this.nodeMax = n;
	}
	// using MD5 to compute the key of a given string
	// if there is a duplicate key, regenerate it
	public String getKey(String input, String range){
		try {
			int tempKey = 0;
			String tempKeyString = "";			
			MessageDigest md = MessageDigest.getInstance("MD5");
			byte[] messageDigest = md.digest(input.getBytes());
			BigInteger no = new BigInteger(1, messageDigest);
			BigInteger key = no.mod(new BigInteger (range));
			tempKeyString = key.toString(10);
			tempKey = Integer.parseInt(tempKeyString);
			while(checkKey.contains(tempKey)){
				System.out.println("Duplicate key: " + tempKeyString + ", try to generate another key.");
				input = input + "avoid confilics";
				md = MessageDigest.getInstance("MD5");
				messageDigest = md.digest(input.getBytes());
				no = new BigInteger(1, messageDigest);
				key = no.mod(new BigInteger (range));
				tempKeyString = key.toString(10);
				tempKey = Integer.parseInt(tempKeyString);
			}
		return tempKeyString;
		}
		catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}
  

	// randomly choose a node then give it's information the the client
	public NodeInfo getNode(){
		Random rand = new Random();
		int index  = rand.nextInt(allNodes.size());
		NodeInfo retNode = allNodes.get(index);
		System.out.println("The getNode() function randomly chose node with ip: " + retNode.nodeIp + " and port: " + retNode.nodePort);
		return retNode;    
	}

	// if the join lock is false, then let node get a random node of the DHT
	// using that node to join the new node into the DHT
	// if the join lock is true, return nack 
	public NodeInfo join(String ip, String port){
        	NodeInfo retNode = new NodeInfo();
		if(!joinLock){
			joinLock = true;
			curIp = ip;
			curPort = port;
			NodeInfo curNode = new NodeInfo();
			curNode.nodeIp = ip;
			curNode.nodePort = port; 
			int key = Integer.parseInt(getKey(ip + ":" + port, "32"));
			checkKey.add(key);
			curNode.nodeKey = key;
			if (allNodes.size() == 0){
				System.out.println("No node in the DHT now, initializing the DHT.");
				retNode.nodeKey = key;
				retNode.nodeIp = "";
				retNode.nodePort = port;
			}
			else {
				retNode = getNode();
				retNode.nodeKey = key;
			}
			allNodes.add(curNode);
			System.out.println("Now the DHT has size: "+ allNodes.size() + ".");
			System.out.println("The nodes in the DHT has following keys: ");
			for(int i: checkKey){
				System.out.println("Key: " + i );
			}
			if(allNodes.size() == nodeMax) System.out.println("All nodes has been joined in to the DHT, you can do get or set operation in the client node now.");
			else System.out.println("Still need " + (nodeMax - allNodes.size()) + " nodes to finish the DHT.");
		}
		else {
			retNode.nodeIp = "nack";
			System.out.println("Busy, try later");
		}
		System.out.println(retNode.nodeIp);
		return retNode;
	}
	
	// unlock the join lock when the join is done
	public boolean postJoin(String ip, String port){
		if(ip.equals(curIp) && port.equals(curPort)){
			System.out.println("Node with ip: " + ip + ", port: " + port + " finishes join the DHT.");
			joinLock = false;
			return true;
		}
		else{
			System.out.println("This node with ip: " + ip + ", port: " + port +" is not the node that is being joined to the DHT");
			System.out.println("This operation is invalid.");
			return false;
		}
	}


}
